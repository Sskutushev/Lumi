# Lumi Performance Optimization Guide

This document details the strategies and tools used to optimize the performance of the Lumi application, covering aspects from rendering efficiency to bundle size and network requests.

## Table of Contents

1.  [Overview](#1-overview)
2.  [Rendering Optimizations](#2-rendering-optimizations)
3.  [Bundle Size and Loading Performance](#3-bundle-size-and-loading-performance)
4.  [Data Fetching and Caching](#4-data-fetching-and-caching)
5.  [Image Optimization](#5-image-optimization)
6.  [Progressive Web App (PWA)](#6-progressive-web-app-pwa)
7.  [Measuring Performance](#7-measuring-performance)

## 1. Overview

Performance is a critical aspect of the Lumi application, aiming to provide a fast, smooth, and responsive user experience. Various techniques are employed across the frontend and data layers to achieve this goal.

## 2. Rendering Optimizations

Efficient rendering is crucial for a responsive UI, especially in React applications.

- **`React.memo`**: Pure functional components, such as `TaskItem`, are wrapped with `React.memo` to prevent unnecessary re-renders when their props have not changed. This is particularly effective for list items or components that receive stable props.
- **`useMemo`**: Used to memoize expensive computations. For example, `filteredTasks` in `TodoDashboard.tsx` and `ProjectView.tsx` are memoized to avoid re-calculating filtered lists on every render if dependencies haven't changed.
- **`useCallback`**: Used to memoize callback functions passed down to child components. This prevents child components from re-rendering unnecessarily when the parent component re-renders, especially when used in conjunction with `React.memo`. Examples include `addTask`, `handleUpdateTask`, `toggleComplete`, and `handleDeleteTask` in `TodoDashboard.tsx` and `ProjectView.tsx`.

## 3. Bundle Size and Loading Performance

Optimizing the application's bundle size and initial loading time is essential for a fast first paint and Time-to-Interactive.

- **Code Splitting (Lazy Loading)**: Pages and larger components are loaded asynchronously using dynamic `import()` statements. This ensures that only the necessary code is loaded for the initial view, reducing the main bundle size.
  - Implemented for main routes and potentially for modals or less frequently used features.
- **Tree Shaking**: Vite automatically performs tree-shaking, removing unused code from the final bundle.
- **Minification**: JavaScript, CSS, and HTML are minified during the build process to reduce file sizes.
- **`rollup-plugin-visualizer`**: Integrated into `vite.config.ts`, this plugin generates a visual representation of the bundle, allowing developers to identify and optimize large dependencies. To use it, run `npm run build` and then open `dist/stats.html`.

## 4. Data Fetching and Caching

`@tanstack/react-query` is central to optimizing data fetching and management.

- **Automatic Caching**: Data fetched via `useQuery` is automatically cached, preventing redundant network requests.
- **Background Re-fetching**: React Query intelligently re-fetches data in the background (e.g., on window focus, after mutations) to ensure the UI is always up-to-date without blocking user interaction.
- **Stale-While-Revalidate (SWR) Strategy**: Configured with `staleTime` and `cacheTime` to balance data freshness and performance.
- **Optimistic Updates**: `useMutation` hooks are configured to perform optimistic updates, immediately updating the UI after a user action and then reverting if the API call fails, providing a highly responsive feel.
- **Query Invalidation**: After successful mutations, relevant queries are automatically invalidated, triggering a background re-fetch to update the UI with the latest data from the server.

## 5. Image Optimization

Images are often a significant contributor to page weight.

- **Responsive Images**: Using `srcset` and appropriate image sizes to serve optimized images based on the user's device and viewport.
- **Modern Formats**: Converting images to modern formats like WebP for better compression and quality.
- **Lazy Loading**: Implementing lazy loading for images that are not immediately visible in the viewport.

## 6. Progressive Web App (PWA)

The application is configured as a PWA, enhancing performance and user experience.

- **Service Worker**: Generated by `vite-plugin-pwa`, the Service Worker caches static assets, enabling instant loading on repeat visits and providing offline capabilities.
- **Offline Support**: Users can access core functionalities even without a network connection, with data being synchronized once online.
- **Installability**: Allows users to install the application to their home screen, providing an app-like experience.

## 7. Measuring Performance

Regularly measuring and monitoring performance is key to identifying and addressing bottlenecks.

- **Browser Developer Tools**:
  - **Performance Tab**: For detailed CPU and network activity profiling.
  - **Network Tab**: To analyze network requests, their timing, and sizes.
  - **Lighthouse**: Built-in audit tool for comprehensive performance, accessibility, SEO, and best practices scores.
- **PageSpeed Insights**: Google's tool for analyzing web page performance on both mobile and desktop, providing field data and lab data.
- **Sentry Performance Monitoring**: Integrated to capture and report real-world performance metrics (e.g., transaction durations, Web Vitals) from production users.
- **`rollup-plugin-visualizer`**: As mentioned, use `npm run build` and open `dist/stats.html` to visualize the bundle composition.
